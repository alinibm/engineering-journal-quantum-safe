---
title: Optional Services
description: Running Guardium Insights with QSPM on EKS
sidebar:
  label: Optional Services
  order: 4
---

## Export the following vars. 

These should be relevant to your environment, therefore clustername should be your clustername and same with your hostname. Below this is an example.

```bash
export clustername=gi-east
export region=us-east-1
export NAMESPACE=openshift-marketplace
export HOSTNAME=apps.gi.thinkforward.work
```

## (Optional) Install the ALB ingress controller

Unlike NGINX Ingress, ALB generates a load balancer when a external service is created in the cluster. So DNS is not necessary. See example [here](https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html#application-load-balancer-sample-application).

Download an IAM policy for the AWS Load Balancer Controller that allows it to make calls to AWS APIs on your behalf.

:::info 

As of this writing, the latest version of AWS Load Balancer Controller is [v2.9.0](https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases/tag/v2.9.0)

:::

```tsx
curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.9.0/docs/install/iam_policy.json
```

Create an IAM policy using the policy downloaded in the previous step. 

```tsx
aws iam create-policy \
    --policy-name AWSLoadBalancerControllerIAMPolicy \
    --tags '{"Key": "Product","Value": "Guardium"}' \
    --policy-document file://iam_policy.json
```

Should return

```tsx
{
    "Policy": {
        "PolicyName": "AWSLoadBalancerControllerIAMPolicy",
        "PolicyId": "ANPA3WENOYSATHNEI5OIR",
        "Arn": "arn:aws:iam::<ACCOUNT ID>:policy/AWSLoadBalancerControllerIAMPolicy",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 0,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2024-09-30T21:08:03+00:00",
        "UpdateDate": "2024-09-30T21:08:03+00:00",
        "Tags": [
            {
                "Key": "Product",
                "Value": "Guardium"
            }
        ]
    }
}

```

Letâ€™s export that policy arn as another env var

```tsx
export alb_policy_arn=$(aws iam list-policies --query 'Policies[?PolicyName==`AWSLoadBalancerControllerIAMPolicy`].Arn' --output text)
```

Export the role name as a env var. We're going to append the cluster name to the role name to help identify it in AWS and in case we have multiple clusters in the same account.
```tsx
export alb_role_name=AWSLoadBalancerControllerRole-${clustername}
```

Create a Kubernetes service account named aws-load-balancer-controller in the kube-system namespace for the AWS Load Balancer Controller and annotate the Kubernetes service account with the name of the IAM role.

```tsx
eksctl create iamserviceaccount \
    --cluster ${clustername} \
    --namespace kube-system \
    --name aws-load-balancer-controller \
    --role-name ${alb_role_name} \
    --attach-policy-arn ${alb_policy_arn} \
    --tags "Product=Guardium" \
    --approve \
    --region ${region}

```

Now let's use helm to install the AWS Load Balancer Controller

Install the helm repo

```tsx
helm repo add eks https://aws.github.io/eks-charts
helm repo update
```

Now install the ALB controller

```tsx
helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
  -n kube-system \
  --set clusterName=${clustername} \
  --set serviceAccount.create=false \
  --set serviceAccount.name=aws-load-balancer-controller 

```

Should return something like this
```tsx
NAME: aws-load-balancer-controller
LAST DEPLOYED: Mon Sep 30 17:21:43 2024
NAMESPACE: kube-system
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
AWS Load Balancer controller installed!
```

Verify the ingress class has been created

```tsx
kubectl get ingressclass
```

should return

```tsx {2}
NAME    CONTROLLER             PARAMETERS   AGE
alb     ingress.k8s.aws/alb    <none>       79s
nginx   k8s.io/ingress-nginx   <none>       35d
```

## Use AWS CA (ACM) for certs (optional)

If you plan to use a private CA via AWS ACM instead of something like LetsEncrypt by default, follow these steps

The AWS PrivateCA Issuer plugin acts as an addon (see external cert configuration) to cert-manager that signs certificate requests using ACM Private CA.

### Create the namespace

```tsx
kubectl create namespace aws-pca-issuer
```

Add the helm repo

```tsx
helm repo add awspca https://cert-manager.github.io/aws-privateca-issuer
helm repo update
helm install awspca/aws-privateca-issuer --generate-name --namespace aws-pca-issuer
```

### Create the private CA in ACM

:::note[Links]
This is using an example from this helpful AWS [link](https://docs.aws.amazon.com/privateca/latest/userguide/create-CA.html)

Generating and installing the CA cert [here](https://docs.aws.amazon.com/privateca/latest/userguide/PCACertInstall.html)
:::

:::note
In our example we are using the subdomain `apps.gi.thinkforward.work`. This will not be the domain you will likely use.
:::

Create the following file and populate it with appropriate values. This file is an EXAMPLE:

```tsx
cat <<EOF > ca_config.txt
{
   "KeyAlgorithm":"RSA_2048",
   "SigningAlgorithm":"SHA256WITHRSA",
   "Subject":{
      "Country":"US",
      "Organization":"IBM",
      "OrganizationalUnit":"Client Engineering",
      "State":"MA",
      "Locality":"Cambridge",
      "CommonName":"$HOSTNAME"
   }
}
EOF
```

We're going to use the default OCSP settings. Now create a revocation file
```tsx
cat <<EOF > revoke_config.txt
{
   "OcspConfiguration":{
      "Enabled":true
   }
}
EOF
```

Finally, create the CA
```tsx
aws acm-pca create-certificate-authority \
     --certificate-authority-configuration file://ca_config.txt \
     --revocation-configuration file://revoke_config.txt \
     --certificate-authority-type "ROOT" \
     --idempotency-token 01234567 \
     --region $region \
     --tags Key=Product,Value=Guardium
```

This should return the new CA's arn.

```tsx
{
    "CertificateAuthorityArn": "arn:aws:acm-pca:us-east-1:748107796891:certificate-authority/00c9d3eb-c837-4cef-917a-fd87ec608a04"
}
```

Let's collect that arn into an env var

{/*
```tsx
export ca_arn=$(aws acm-pca list-certificate-authorities --query "CertificateAuthorities[].Arn" --region $region --output text --max-items 1)
```
*/}

```tsx
export ca_arn="arn:aws:acm-pca:us-east-1:748107796891:certificate-authority/00c9d3eb-c837-4cef-917a-fd87ec608a04"
```

### Generate and install the CA cert

Generate a certificate signing request (CSR).

```tsx
aws acm-pca get-certificate-authority-csr \
     --certificate-authority-arn $ca_arn \
     --output text \
     --region $region > ca.csr
```

Using the CSR from the previous step as the argument for the --csr parameter, issue the root certificate and export the arn as another env var.

```tsx
export root_cert_arn=$(aws acm-pca issue-certificate \
     --certificate-authority-arn $ca_arn \
     --csr fileb://ca.csr \
     --signing-algorithm SHA256WITHRSA \
     --region $region \
     --template-arn arn:aws:acm-pca:::template/RootCACertificate/V1 \
     --validity Value=365,Type=DAYS \
     --output text)
```
{/*"CertificateArn": "arn:aws:acm-pca:us-east-1:803455550593:certificate-authority/3c6802d4-b875-4df8-8ac9-a616c36c3915/certificate/b3bd35d6e7d5acf0a4e3697c903dc82f"*/}

Retrieve the cert and let's stick it in `cert.pem`

```tsx
aws acm-pca get-certificate \
	--certificate-authority-arn $ca_arn \
	--certificate-arn $root_cert_arn \
  --region $region \
	--output text > cert.pem
```

Finally import it into the CA

```tsx
aws acm-pca import-certificate-authority-certificate \
    --region $region \
    --certificate-authority-arn $ca_arn \
    --certificate fileb://cert.pem
```

Verify the status of the CA

```tsx
aws acm-pca describe-certificate-authority \
  --region $region \
	--certificate-authority-arn $ca_arn \
  --query "CertificateAuthority.Status" \
	--output text
```

This should return `ACTIVE`.

### Create an ACM Private CA

Download the CA certificate using the following command.
```tsx
aws acm-pca get-certificate-authority-certificate \
--certificate-authority-arn $ca_arn \
--region $region \
--output text > cacert.pem
```

### Set EKS node permission for ACM Private CA

Add the IAM policy to your EKS NodeInstanceRole

Create the following file

```tsx
cat <<EOF > EKS-CA-NodePerms-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "awspcaissuer",
            "Action": [
                "acm-pca:DescribeCertificateAuthority",
                "acm-pca:GetCertificate",
                "acm-pca:IssueCertificate"
            ],
            "Effect": "Allow",
            "Resource": "$ca_arn"
        }
    ]
}
EOF
```

Create the policy in IAM. This needs to be specific for your cluster using the CA we created.

Export the following var:

```tsx
export awscapolicy="AWSCAPolicy-${clustername}"
```

```tsx
aws iam create-policy \
--policy-name ${awscapolicy} \
--policy-document file://EKS-CA-NodePerms-policy.json
```

Let's retrieve the policy arn as an env var

```tsx
export ca_policy_arn=$(aws iam list-policies --query 'Policies[?PolicyName==`'${awscapolicy}'`].Arn' --output text)
```

Let's gather our NodeInstance role name

```tsx
export node_instance_role=$(aws iam list-roles --region $region --query 'Roles[?starts_with(RoleName, `eksctl-'${clustername}'`)]|[?contains(RoleName, `NodeInstanceRole`)].RoleName' --output text)
```
Now let's attach the policy to our EKS node role. In our case the role name is `gi-eks-nodes-role`. This may be different for you.
```tsx
aws iam attach-role-policy \
--role-name "${node_instance_role}" \
--policy-arn "${ca_policy_arn}" \
--region "${region}"
```

### Create an issuer

We're going to create a namespace scoped issuer for now.

Create a yaml file for the issuer
```tsx
cat <<EOF > awpca-issuer.yaml
apiVersion: awspca.cert-manager.io/v1beta1
kind: AWSPCAIssuer
metadata:
  name: acm-issuer
  namespace: $NAMESPACE
spec:
  arn: $ca_arn
  region: $region
EOF
```

Deploy the AWSPCAIssuer: 

```tsx
kubectl apply -f awpca-issuer.yaml
```